### 短地址或参数攻击漏洞的原理以及预防
* 原理：
	* 1、在外部应用或外部合约调用智能合约时。当参数传递给智能合约时，参数将根据ABI规范进行编码。
	* 2、外部合约可以发送比预期参数长度短的编码参数（例如，发送一个只有38个十六进制字符，即19个字节长度，而不是标准的20字节长度地址时）
	* 3、在此情况下，EVM将在编码参数的末尾填充0，以弥补预期的长度
	* 4、这样，当智能合约不验证输入的时候，这就会成为一个被攻击的漏洞
	* 5、例子就是，当用户请求提款的时候，交易所将不会验证ERC20令牌的地址
* 实例——transfer转账函数：
	* function transfer(address to, uint tokens) public returns (bool success);
* 攻击原理：
	* 1、EVM将按照transfer()函数指定的顺序来对这些参数进行编码，即先地址然后数量
	* 2、恶意用户可以通过删除以0或者多个0结尾的以太地址的最后一个0来构造这种攻击
* 短地址：
	* 接受用户数据的智能合约允许小于20字节的以太坊地址
	* 通常以太坊地址看起来像：
		* 0xc3Bb35818d58FCA0C4943bA98938cb6F46A91700
	* 如果去掉末尾的两个0（一个十六进制字节等于0）会怎样？
		* EVM会接受它，但在打包的功能参数末尾添加额外的0
		* 从给出一个短参数的点开始，传递函数将移动一个字节，这将移动传递的令牌数量
* 攻击过程：
	* 假设用户有100个代币，但是想要25600个，怎么做？
		* 1、生成一个结尾为0的以太坊地址。这个虽然有随机性和时间难度，但是可以做到
		* 2、找到一个有25600个代币的兑换钱包，比如交易所
		* 3、向这个交易所钱包发送100个代币，即在我的链外账户内部存入100个代币
		* 3、请求使用我生成的地址提取100个代币（去掉地址中最后一个“0”字节）
* 攻击结果：
	* 假设目标合约不验证地址，那么它将把所有内容“打包”在一起
		* 1、将转出代币数量（最后一个参数）移动到上一个字节上
		* 2、当需要68个字节时，实际向传输函数传递了67个字节的参数
		* 3、正确的打包数据长度应该是68个字节，其中前4个字节是transfer()函数签名
		* 4、第二个是32个字节地址，后面最后32个字节代表是uint256的令牌数量（它有很多前导零）
		* 5、所有这些参数都在msg.data下传递调用，在这种攻击中所发生的是，前导0的一个字节被从数量中取出，并给缩短的地址
		* 6、这将给我们留下与开始时相同的地址，所以发送到这里的代币是可以转账的
		* 7、当EVM检测到在处理256位数据的时候发生下溢(小于256位)，则在地址的末尾追加0。这意味着你的金额乘以了 1<<8 或 256。最重要的是，交易所在他们的内部账本上检查了你的余额
* 攻击的预防：
	* 一个比较简单的方法是在合约的转账函数中检测msg.data的长度是不是正确的68字节大小
		*  assert(msg.data.length >= size + 4);